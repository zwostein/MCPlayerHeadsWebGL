<html>
<head>
	<title>MC Player Head in WebGL Test</title>
	<style>
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>

<script src="https://raw.github.com/mrdoob/three.js/master/build/three.js"></script>

<script>
var scene;
var camera;
var renderer;
/*
var targetXRotation = 0;
var targetXRotationOnMouseDown = 0;
var targetYRotation = 0;
var targetYRotationOnMouseDown = 0;
var mouseX = 0;
var mouseXOnMouseDown = 0;
var mouseY = 0;
var mouseYOnMouseDown = 0;
*/
var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;


PlayerHead = function( name )
{
	THREE.Mesh.call( this );	// inherit from THREE.Mesh
	this.texture = THREE.ImageUtils.loadTexture( name+'.png' );
	this.texture.magFilter = THREE.NearestFilter;
	this.material = new THREE.MeshLambertMaterial( { side:THREE.DoubleSide, alphaTest:0.999, map:this.texture } );
	this.geometry = new THREE.Geometry();
	function pushNewMCCube( geometry, scale, texOffset )
	{
		var faceStartIndex = geometry.vertices.length;
		geometry.vertices.push( new THREE.Vector3( -scale, -scale,  scale ) );	// 0 - frontBottomLeft
		geometry.vertices.push( new THREE.Vector3(  scale, -scale,  scale ) );	// 1 - frontBottomRight
		geometry.vertices.push( new THREE.Vector3(  scale,  scale,  scale ) );	// 2 - frontTopRight
		geometry.vertices.push( new THREE.Vector3( -scale,  scale,  scale ) );	// 3 - frontTopLeft
		geometry.vertices.push( new THREE.Vector3( -scale, -scale, -scale ) );	// 4 - backBottomLeft
		geometry.vertices.push( new THREE.Vector3(  scale, -scale, -scale ) );	// 5 - backBottomRight
		geometry.vertices.push( new THREE.Vector3(  scale,  scale, -scale ) );	// 6 - backTopRight
		geometry.vertices.push( new THREE.Vector3( -scale,  scale, -scale ) );	// 7 - backTopLeft
		geometry.faces.push( new THREE.Face4( faceStartIndex+0, faceStartIndex+1, faceStartIndex+2, faceStartIndex+3 ) );	// front
		geometry.faces.push( new THREE.Face4( faceStartIndex+5, faceStartIndex+4, faceStartIndex+7, faceStartIndex+6 ) );	// back
		geometry.faces.push( new THREE.Face4( faceStartIndex+4, faceStartIndex+0, faceStartIndex+3, faceStartIndex+7 ) );	// left
		geometry.faces.push( new THREE.Face4( faceStartIndex+1, faceStartIndex+5, faceStartIndex+6, faceStartIndex+2 ) );	// right
		geometry.faces.push( new THREE.Face4( faceStartIndex+3, faceStartIndex+2, faceStartIndex+6, faceStartIndex+7 ) );	// top
		geometry.faces.push( new THREE.Face4( faceStartIndex+4, faceStartIndex+5, faceStartIndex+1, faceStartIndex+0 ) );	// bottom
		geometry.faceVertexUvs[0].push( [	new THREE.UV( texOffset+1.0/8.0, 2.0/4.0 ),
							new THREE.UV( texOffset+2.0/8.0, 2.0/4.0 ),
							new THREE.UV( texOffset+2.0/8.0, 3.0/4.0 ),
							new THREE.UV( texOffset+1.0/8.0, 3.0/4.0 )	] );
		geometry.faceVertexUvs[0].push( [	new THREE.UV( texOffset+3.0/8.0, 2.0/4.0 ),
							new THREE.UV( texOffset+4.0/8.0, 2.0/4.0 ),
							new THREE.UV( texOffset+4.0/8.0, 3.0/4.0 ),
							new THREE.UV( texOffset+3.0/8.0, 3.0/4.0 )	] );
		geometry.faceVertexUvs[0].push( [	new THREE.UV( texOffset+0.0/8.0, 2.0/4.0 ),
							new THREE.UV( texOffset+1.0/8.0, 2.0/4.0 ),
							new THREE.UV( texOffset+1.0/8.0, 3.0/4.0 ),
							new THREE.UV( texOffset+0.0/8.0, 3.0/4.0 )	] );
		geometry.faceVertexUvs[0].push( [	new THREE.UV( texOffset+2.0/8.0, 2.0/4.0 ),
							new THREE.UV( texOffset+3.0/8.0, 2.0/4.0 ),
							new THREE.UV( texOffset+3.0/8.0, 3.0/4.0 ),
							new THREE.UV( texOffset+2.0/8.0, 3.0/4.0 )	] );
		geometry.faceVertexUvs[0].push( [	new THREE.UV( texOffset+1.0/8.0, 3.0/4.0 ),
							new THREE.UV( texOffset+2.0/8.0, 3.0/4.0 ),
							new THREE.UV( texOffset+2.0/8.0, 4.0/4.0 ),
							new THREE.UV( texOffset+1.0/8.0, 4.0/4.0 )	] );
		geometry.faceVertexUvs[0].push( [	new THREE.UV( texOffset+2.0/8.0, 3.0/4.0 ),
							new THREE.UV( texOffset+3.0/8.0, 3.0/4.0 ),
							new THREE.UV( texOffset+3.0/8.0, 4.0/4.0 ),
							new THREE.UV( texOffset+2.0/8.0, 4.0/4.0 )	] );
	}
	pushNewMCCube( this.geometry, 1.0, 0 );
	pushNewMCCube( this.geometry, 1.1, 0.5 );
	this.geometry.computeFaceNormals();
	this.geometry.computeCentroids();
	this.geometry.computeVertexNormals();
	this.geometry.computeBoundingSphere();
	this.boundRadius = this.geometry.boundingSphere.radius;
	return this;
};
PlayerHead.prototype = Object.create( THREE.Mesh.prototype );
PlayerHead.prototype.constructor = PlayerHead;


function init()
{
	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
	renderer = new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	var playername = prompt("Bitte Spielernamen eingeben", "jeb_");
	playerHead = new PlayerHead( playername );
	scene.add( playerHead );
	
	camera.position.z = 5;
	
	var directionalLight = new THREE.DirectionalLight( 0xffffff, 2.0 );
	directionalLight.position.set( 0, 1, 5 );
	scene.add( directionalLight );
/*
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
*/
	window.addEventListener( 'resize', onWindowResize, false );
}

function onWindowResize()
{

	windowHalfX = window.innerWidth / 2;
	windowHalfY = window.innerHeight / 2;
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}
/*
function onDocumentMouseDown( event )
{
	event.preventDefault();
	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	document.addEventListener( 'mouseup', onDocumentMouseUp, false );
	document.addEventListener( 'mouseout', onDocumentMouseOut, false );
	mouseXOnMouseDown = event.clientX - windowHalfX;
	mouseYOnMouseDown = event.clientY - windowHalfY;
	targetXRotationOnMouseDown = targetXRotation;
	targetYRotationOnMouseDown = targetYRotation;
}

function onDocumentMouseMove( event )
{
	mouseX = event.clientX - windowHalfX;
	mouseY = event.clientY - windowHalfY;
	targetXRotation = targetXRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.005;
	targetYRotation = targetYRotationOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.005;
}

function onDocumentMouseUp( event )
{
	document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
	document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
	document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
}

function onDocumentMouseOut( event )
{
	document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
	document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
	document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
}
*/
// random lookat quaternion generator
var randomLookAt = new THREE.Quaternion();
function newRandomLookAt()
{
	var random = new THREE.Vector3( -Math.random()*50+25, Math.random()*50-25, -Math.random()*50-10 );
	var mat = new THREE.Matrix4();
	mat.lookAt( new THREE.Vector3(0,0,0), random, new THREE.Vector3(0,1,0) );
	randomLookAt.setFromRotationMatrix( mat );
	var randomLookAtTimeout = setTimeout( newRandomLookAt, Math.random()*7000+1000 );
}
var randomLookAtTimeout = setTimeout( newRandomLookAt, Math.random()*7000+1000 );
newRandomLookAt();

function render()
{
	requestAnimationFrame( render );

	// random movement
	playerHead.useQuaternion = true;
	var playerHeadNew = new THREE.Quaternion();
	THREE.Quaternion.slerp( playerHead.quaternion, randomLookAt, playerHeadNew, 0.04 );
	playerHead.quaternion = playerHeadNew;
/*
	// mouse control
	playerHead.rotation.x = targetYRotation;
	playerHead.rotation.y = targetXRotation;
*/
	renderer.render( scene, camera );
}

init();
render();
</script>

</body>
</html>
